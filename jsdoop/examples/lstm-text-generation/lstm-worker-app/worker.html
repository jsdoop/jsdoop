<html>

<head>
  <title>Web-Distributed Computation: LSTM text generation worker</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    .wde-example-container {
      width: calc(100vw - 600px);
    }

    .pred {
      font-size: 30px;
      width: 100px;
    }

    .pred-correct {
      background-color: #00cf00;
    }

    .pred-incorrect {
      background-color: red;
    }

    .pred-container {
      display: inline-block;
      width: 100px;
      margin: 10px;
    }


    body {
        background: ghostwhite;
    }
  
    .onoffswitch {
      margin: 0 auto;
    }

    .text-container {
      text-align: center;
    }


    .included_html {
      display: none;
      width:50% !important;
    }


    #stats-container {
      display: table !important;
      width: 95vw !important;
    }

    #charts-table {
      display: table-row !important;
      width:100% !important;
    }


  </style>
</head>

<body>
  <div class="out-text-container">
    <div class="text-container">
      <section class='title-area'>
        <h1>Worker</h1>
      </section>

      <section class='description-area'>
        <p>
          This page is running a worker that consumes tasks from the master server.
        </p>
        <span>Toggle to show/hide Stats.</span>
        <div class="onoffswitch">
            <input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="myonoffswitch" unchecked>
            <label class="onoffswitch-label" for="myonoffswitch">
                <span class="onoffswitch-inner"></span>
                <span class="onoffswitch-switch"></span>
            </label>
        </div>            
      </section>
    </div>
  </div>





 <!-- <div class="out-stats-container"> -->
    <div id ="stats-container">
       <!-- <input type="text" id="tasksSolvedPerSecond" readonly> -->
          <!-- stats.html -->
          <div class = "included_html included_html0" id = "included_html0">
             <script async="" src="./js/analytics.js"></script><script src="./js/Chart.min.js"></script>
             <script src="./js/utils.js"></script>
             <style>
                .canvas {
                -moz-user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
                }
             </style>
             <style type="text/css">/* Chart.js */
                @keyframes chartjs-render-animation{from{opacity:.99}to{opacity:1}}.chartjs-render-monitor{animation:chartjs-render-animation 1ms}.chartjs-size-monitor,.chartjs-size-monitor-expand,.chartjs-size-monitor-shrink{position:absolute;direction:ltr;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1}.chartjs-size-monitor-expand>div{position:absolute;width:1000000px;height:1000000px;left:0;top:0}.chartjs-size-monitor-shrink>div{position:absolute;width:200%;height:200%;left:0;top:0}
             </style>
             <div class="outside_canvas" style="width:100%;">
                <div class="chartjs-size-monitor">
                   <div class="chartjs-size-monitor-expand">
                      <div class=""></div>
                   </div>
                   <div class="chartjs-size-monitor-shrink">
                      <div class=""></div>
                   </div>
                </div>
                <canvas class ="canvas" id="canvas_stats" class="chartjs-render-monitor"></canvas>
             </div>
             <script>
                let statsChart = {};
                
                (() => {
                
                  let maxElementsInChart = 100; //Cuando se pasa del límite se eliminan algunos puntos intermedios.
                  let removeEachNth = 30;
                
                  //statsChart.update = function (chart, statsSummary, mappersOrReducers) {
                  statsChart.update = function (statsSummary) {
                    let chart = statsChart.chart;
                    //let mappersOrReducers = "mappers";
                    //console.log("!!!!!!!! " + mappersOrReducers);
                    //if (mappersOrReducers) mappersOrReducers = "mappers";
                    //else mappersOrReducers = "reducers";
                   
                    let mappersOrReducers = "tasks";
                
                    if (!statsSummary[mappersOrReducers]["avgProcTime"]) return;
                
                    let newDate = new Date(statsSummary.timeStamp);
                    chart.data.labels.push(newDate);
                
                   
                      //TESTING
                      console.log("!!!!!!!!! chart.data.labels.length = " + chart.data.labels.length);
                      console.log("!!!!!!!!! chart.data.labels = " + chart.data.labels);
                
                      console.log("!!!!!!!!! statsSummary = " + statsSummary);
                      console.log("!!!!!!!!! statsSummary[" + mappersOrReducers + "] = " + statsSummary[mappersOrReducers]);
                      console.log("!!!!!!!!! statsSummary.timeStamp = " + statsSummary.timeStamp);
                
                      console.log("!!!!!!!!! chart.data.datasets[0].data = " + JSON.stringify(chart.data.datasets[0].data));
                      console.log("!!!!!!!!! chart.data.datasets[1].data = " + JSON.stringify(chart.data.datasets[1].data));
                
                      console.log("!!!!!!!!! chart.data.datasets[0].data.length = " + chart.data.datasets[0].data.length);
                      console.log("!!!!!!!!! chart.data.datasets[1].data.length = " + chart.data.datasets[1].data.length);
                      console.log("!!!!!!!!! chart.data.datasets[2].data.length = " + chart.data.datasets[2].data.length);
                      console.log("!!!!!!!!! --------------------------------------------");
                     
                
                    chart.data.datasets[0].data.push({x: newDate, y: statsSummary[mappersOrReducers]["maxProcTime"] / 1000} );
                
                    let avgSeconds = statsSummary[mappersOrReducers]["avgProcTime"] / 1000;
                    let sdSeconds = statsSummary[mappersOrReducers]["sdProcTime"] / 1000;
                    chart.data.datasets[1].data.push({x: newDate, y: avgSeconds + sdSeconds} ); 
                    chart.data.datasets[2].data.push({x: newDate, y: avgSeconds} ); 
                    chart.data.datasets[3].data.push({x: newDate, y: avgSeconds - sdSeconds } ); 
                
                    chart.data.datasets[4].data.push({x: newDate, y: statsSummary[mappersOrReducers]["minProcTime"] / 1000} );  
                
                    //Removing 1 label that is created automatically. To get the same number of elements in all arrays.
                    if (chart.data.labels.length > chart.data.datasets[0].data.length) chart.data.labels.shift();
                
                    if (chart.data.labels.length > maxElementsInChart) {
                      for (let i = chart.data.labels.length - 2; i > 0; i--) { //Remove each nth element. Do not remove first and last.
                        (i + 1) % removeEachNth === 0 && chart.data.labels.splice(i, 1) && chart.data.datasets[0].data.splice(i, 1) && chart.data.datasets[1].data.splice(i, 1) && chart.data.datasets[2].data.splice(i, 1) && chart.data.datasets[3].data.splice(i, 1) && chart.data.datasets[4].data.splice(i, 1);
                      }
                    }
                
                    window.myLine.update();
                  }
                
                  statsChart.reset = function () {
                    for (let i = 0; i < statsChart.chart.data.datasets.length; i++) {
                      statsChart.chart.data.datasets[i].data = [];
                      statsChart.chart.data.labels = [];
                    }
                  }
                
                  statsChart.load = function () {
                  //https://stackoverflow.com/questions/41467923/chart-js-fill-between-two-lines
                  ///////////////////////////////////////////////////////
                      var fillBetweenLinesPlugin = {
                      afterDatasetsDraw: function (chart) {
                          var ctx = chart.chart.ctx;
                          var xaxis = chart.scales['x-axis-0'];
                          var yaxis = chart.scales['y-axis-0'];
                          var datasets = chart.data.datasets;
                          ctx.save();
                
                          for (var d = 0; d < datasets.length; d++) {
                              var dataset = datasets[d];
                              if (dataset.fillBetweenSet == undefined) {
                                  continue;
                              }
                
                              // get meta for both data sets
                              var meta1 = chart.getDatasetMeta(d);
                              var meta2 = chart.getDatasetMeta(dataset.fillBetweenSet);
                
                              // do not draw fill if one of the datasets is hidden
                              if (meta1.hidden || meta2.hidden) continue;
                
                              // create fill areas in pairs
                              for (var p = 0; p < meta1.data.length-1;p++) {
                                  // if null skip
                                if (dataset.data[p] == null || dataset.data[p+1] == null) continue;
                
                                ctx.beginPath();
                
                                // trace line 1
                                var curr = meta1.data[p];
                                var next = meta1.data[p+1];
                                ctx.moveTo(curr._view.x, curr._view.y);
                                ctx.lineTo(curr._view.x, curr._view.y);
                                if (curr._view.steppedLine === true) {
                                  ctx.lineTo(next._view.x, curr._view.y);
                                  ctx.lineTo(next._view.x, next._view.y);
                                }
                                else if (next._view.tension === 0) {
                                  ctx.lineTo(next._view.x, next._view.y);
                                }
                                else {
                                    ctx.bezierCurveTo(
                                      curr._view.controlPointNextX,
                                      curr._view.controlPointNextY,
                                      next._view.controlPointPreviousX,
                                      next._view.controlPointPreviousY,
                                      next._view.x,
                                      next._view.y
                                    );
                                              }
                
                                // connect dataset1 to dataset2
                                var curr = meta2.data[p+1];
                                var next = meta2.data[p];
                                ctx.lineTo(curr._view.x, curr._view.y);
                
                                // trace BACKWORDS set2 to complete the box
                                if (curr._view.steppedLine === true) {
                                  ctx.lineTo(curr._view.x, next._view.y);
                                  ctx.lineTo(next._view.x, next._view.y);
                                }
                                else if (next._view.tension === 0) {
                                  ctx.lineTo(next._view.x, next._view.y);
                                }
                                else {
                                  // reverse bezier
                                  ctx.bezierCurveTo(
                                    curr._view.controlPointPreviousX,
                                    curr._view.controlPointPreviousY,
                                    next._view.controlPointNextX,
                                    next._view.controlPointNextY,
                                    next._view.x,
                                    next._view.y
                                  );
                                }
                
                                              // close the loop and fill with shading
                                ctx.closePath();
                                ctx.fillStyle = dataset.fillBetweenColor || "rgba(0,0,0,0.1)";
                                ctx.fill();
                              } // end for p loop
                          }
                      } // end afterDatasetsDraw
                  }; // end fillBetweenLinesPlugin
                
                  Chart.pluginService.register(fillBetweenLinesPlugin);
                  //////////////////////////////////////////////////////
                
                
                
                
                
                	  statsChart.chart = {
                		  type: 'line',
                		  data: {
                        labels: [],
                			  datasets: [{
                				  label: 'Max Time (s)',
                				  backgroundColor: window.chartColors.red,
                				  borderColor: window.chartColors.red,
                				  fill: false,
                          tension: 0,
                				  data: [
                
                				  ],
                			  }, 
                        {
                				  label: 'Mean Time + SD (s)',
                				  backgroundColor: window.chartColors.gray,
                				  borderColor: window.chartColors.gray,
                				  fill: false,
                          tension: 0,
                          fillBetweenSet: 1,
                          fillBetweenColor: "rgba(0,0,255, 0.2)",
                				  data: [
                
                				  ],
                          borderDash: [10,5]
                			  },
                        {
                				  label: 'Mean Time (s)',
                				  backgroundColor: window.chartColors.blue,
                				  borderColor: window.chartColors.blue,
                				  fill: false,
                          tension: 0,
                          fillBetweenSet: 1,
                          //fillBetweenColor: "rgba(255,0,0, 0.2)",
                				  data: [
                
                				  ]
                			  },
                        {
                				  label: 'Mean Time - SD (s)',
                				  backgroundColor: window.chartColors.gray,
                				  borderColor: window.chartColors.gray,
                				  fill: false,
                          tension: 0,
                          fillBetweenSet: 1,
                          fillBetweenColor: "rgba(0,0,255, 0.2)",
                				  data: [
                
                				  ],
                          borderDash: [10,5]
                			  },
                        {
                				  label: 'Min Time (s)',
                				  backgroundColor: window.chartColors.green,
                				  borderColor: window.chartColors.green,
                				  fill: false,
                          tension: 0,
                				  data: [
                
                				  ],
                			  }
                        ]
                		  },
                		  options: {
                        cubicInterpolationMode: 'default',
                        bezierCurve: false,
                        lineTension: 0,
                			  responsive: true,
                			  title: {
                				  display: true,
                				  text: 'Statistics for processing time of a task for all volunteer devices.'
                			  },
                			  scales: {
                            xAxes: [
                              { labelString: "Date", display: false, position: 'top', barPercentage: 1.0, categoryPercentage: 0.5 }
                              //,
                              //{ type: 'time', time: { format: "HH:MM:SS"} }          
                            ] 
                          ,
                				  yAxes: [{
                            labelString: "Time (s)",
                					  display: true,
                            ticks: {
                              beginAtZero: true
                            }          
                					  //type: 'logarithmic',
                				  }]
                			  }
                		  }
                	  };
                
                	  //window.onload = function() {
                    //window.onload = function() {
                		  let ctx = document.getElementById('canvas_stats').getContext('2d');
                		  window.myLine = new Chart(ctx, statsChart.chart);
                
                	  //};
                    
                  }
                
                
                
                })();
                
                 // alert("statsChart = " + statsChart);
                  //alert("statsChart.init = " + statsChart.init);
                  //charts.push(statsChart);
                  //statsChart.init();
                
                	
             </script>
          </div>

          <!-- percentage.html -->
          <div class = "included_html included_html1" id = "included_html1">
             <script async="" src="./js/analytics.js"></script><script src="./js/Chart.min.js"></script>
             <script src="./js/utils.js"></script>
             <style>
                .canvas {
                -moz-user-select: none;
                -webkit-user-select: none;
                -ms-user-select: none;
                }
             </style>
             <style type="text/css">/* Chart.js */
                @keyframes chartjs-render-animation{from{opacity:.99}to{opacity:1}}.chartjs-render-monitor{animation:chartjs-render-animation 1ms}.chartjs-size-monitor,.chartjs-size-monitor-expand,.chartjs-size-monitor-shrink{position:absolute;direction:ltr;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1}.chartjs-size-monitor-expand>div{position:absolute;width:1000000px;height:1000000px;left:0;top:0}.chartjs-size-monitor-shrink>div{position:absolute;width:200%;height:200%;left:0;top:0}
             </style>
             <div class="outside_canvas" style="width:100%;">
                <div class="chartjs-size-monitor">
                   <div class="chartjs-size-monitor-expand">
                      <div class=""></div>
                   </div>
                   <div class="chartjs-size-monitor-shrink">
                      <div class=""></div>
                   </div>
                </div>
                <canvas class ="canvas" id="canvas_percentage" class="chartjs-render-monitor"></canvas>
             </div>
             <script>
                let percentageChart = {};
                
                
                (() => {
                
                
                let maxElementsInChart = 100; //Cuando se pasa del límite se eliminan algunos puntos intermedios.
                let removeEachNth = 30;
                
                percentageChart.update = function (statsSummary) {
                
                  if (!statsSummary || !statsSummary.taskSolvedPerSecond) return;
                
                  let chart = percentageChart.chart;  
                
                  let newDate = new Date(statsSummary.timeStamp);
                  chart.data.labels.push(newDate);
                  
                
                  chart.data.datasets[0].data.push({x: newDate, y: statsSummary.taskSolvedPerSecond });
                  chart.data.datasets[1].data.push({x: newDate, y: statsSummary.nWorkers });
                
                  //Removing 1 label that is created automatically. To get the same number of elements in all arrays.
                  if (chart.data.labels.length > chart.data.datasets[0].data.length) chart.data.labels.shift();
                
                  if (chart.data.labels.length > maxElementsInChart) {
                    for (let i = chart.data.labels.length - 2; i > 0; i--) { //Remove each nth element. Do not remove first and last.
                      (i + 1) % removeEachNth === 0 && chart.data.labels.splice(i, 1) && chart.data.datasets[0].data.splice(i, 1) && chart.data.datasets[1].data.splice(i, 1);
                    }
                  }
                
                  window.tasksPerSecondChart.update();
                }
                
                percentageChart.reset = function () {
                  for (let i = 0; i < percentageChart.chart.data.datasets.length; i++) {
                    percentageChart.chart.data.datasets[i].data = [];
                    percentageChart.chart.data.labels = [];
                  }
                }
                
                
                percentageChart.load = function () {
                
                
                	percentageChart.chart = {
                		type: 'line',
                		data: {
                      labels: [],
                			datasets: [{
                				label: 'Tasks solved per second (left)',
                				backgroundColor: window.chartColors.orange,
                				borderColor: window.chartColors.orange,
                				fill: false,
                        tension: 0,
                				data: [
                
                				],
                        yAxisID: 'y-axis-1',
                			},
                        {
                				  label: 'N connected devices (right)',
                				  backgroundColor: window.chartColors.blue,
                				  borderColor: window.chartColors.blue,
                				  fill: false,
                          tension: 0,
                				  data: [
                
                				  ],
                        	yAxisID: 'y-axis-2',
                			  },
                      ]
                		},
                		options: {
                      cubicInterpolationMode: 'default',
                      bezierCurve: false,
                      lineTension: 0,
                			responsive: true,
                			title: {
                				display: true,
                				text: 'Tasks solved per second using N connected devices.'
                			},
                			scales: {
                          xAxes: [
                            { labelString: "Date", display: false, position: 'top', barPercentage: 1.0, categoryPercentage: 0.5 }
                            //,
                            //{ type: 'time', time: { format: "HH:MM:SS"} }          
                          ] 
                        ,
                				yAxes: [{
                          labelString: "Tasks solved per second",
                					display: true,
                					position: 'left',
                					id: 'y-axis-1',
                          ticks: {
                            beginAtZero: true
                          }          
                					//type: 'logarithmic',
                				}, 
                          {
                            labelString: "N connected devices",
                						type: 'linear', // only linear but allow scale type registration. This allows extensions to exist solely for log scale for instance
                						display: true,
                						position: 'right',
                						id: 'y-axis-2',
                            ticks: {
                              beginAtZero: true,
                              stepSize: 1
                            },
                						// grid line settings
                						gridLines: {
                							drawOnChartArea: false, // only want the grid lines for one axis to show up
                						},
                					}
                
                        ]
                			}
                		}
                	};
                
                	//window.onload = function() {
                  //percentageChart.init = function() {
                		let ctx = document.getElementById('canvas_percentage').getContext('2d');
                		window.tasksPerSecondChart = new Chart(ctx, percentageChart.chart);
                	//};
                }
                
                
                
                })();
                
                
                	
             </script>
          </div>

        <div id ="charts-table">

        </div>
    </div>
<!--  </div> -->
<!--
    <input type="checkbox" name="onoffswitch" unchecked>
-->

    <script>
var charts = [];


let toImportAll = document.querySelectorAll('link[rel="import"]');//.import;
// Grab DOM from doc.html's document.
let toImport;
let includedHtml;
for (let i = 0; i < toImportAll.length; i++) {
  toImport = toImportAll[i].import;
  includedHtml = toImport.querySelector('.included_html' + i);
  document.getElementById("charts-table").appendChild(includedHtml.cloneNode(true));
  //document.body.appendChild(includedHtml.cloneNode(true))
}


window.onload = function() {
  charts.push(statsChart);
  charts.push(percentageChart);

  for (let i = 0; i < charts.length; i++) {
    charts[i].load();
  }
}




      let worker = new Worker("./worker.js");


      /*********************************************************************************************************************/
      /* Parámetros de conexión
      /* TODO: sacar de aquí
      /*********************************************************************************************************************/

      const local = true;
      const taskName = 'lstm_text_generation';
      const queueName = taskName + '_queue';
      let serverUrl;
      let port = 15674;
      let user = 'worker';
      let pswd = 'mypassword';
      let webdisPort = 7379;
      if(local) {
        serverUrl = 'localhost';
        user = 'guest';
        pswd = 'guest';
        webdisPort = 3001;
      } else {
        serverUrl = 'mallba3.lcc.uma.es';
      }

      /*********************************************************************************************************************/
      /* LOADING STATS
      /*********************************************************************************************************************/
      async function getText(url) {
        return new Promise((resolve, reject)=> {
          var req = new XMLHttpRequest();
          req.open('GET', url, true);
          req.onreadystatechange = function (aEvt) {
            if (req.readyState == 4) {
               if(req.status == 200) {
                resolve(req.responseText);
               } else {
                console.error("(browser worker.html)Error loading from url" + url + "\n");
                reject("(browser worker.html)Error loading from url " + url + "\n");
               }
            }
          };
          req.send(null);
        });
      }


      let lastStatsJobId = null;
      let showStats = false;
      let stats = {};
      let lastIdStats = 0;
      let idStats = 0;

      async function loadStats(){ 
        
        console.log("loadStats()");
        if (showStats) {
          
          idStats = await getText('http://' + serverUrl + ':' + webdisPort + '/GET/' + taskName + '_stats_date');
          if (idStats != lastIdStats) {
            stats = await getText('http://' + serverUrl + ':' + webdisPort + '/GET/' + taskName + '_stats_summary');
            if (stats) {
              let statsJson = JSON.parse(stats).GET;
              if (statsJson) {
                  statsJson = JSON.parse(statsJson);
              } else {
                setTimeout(function () {      
                  loadStats();
                }, 3000);
                return;
              } 
              if (lastStatsJobId == null) lastStatsJobId = statsJson.idJob;
              //IF DIFFERENT JOB -> RESET CHARTS  
              if (statsJson.idJob != lastStatsJobId) {
                lastStatsJobId = statsJson.idJob;  
                console.log("A new job has been started!!!");
                for (let i = 0; i < charts.length; i++) {
                  charts[i].reset();
                }            
              }


              //let statsJson = JSON.parse(JSON.parse(stats).GET);
              //let inputSpeed = document.getElementById("tasksSolvedPerSecond");
              //inputSpeed.value = statsJson.taskSolvedPerSecond;
              for (let i = 0; i < charts.length; i++) {
                charts[i].update(statsJson);
              }


              console.log("STATS --> " + stats);
              console.log("JSON.stringify(stats) --> " + JSON.stringify(stats));
              lastIdStats = idStats;
            } else {
              console.log("Empty Stats!!");   
            }

          } else {
            console.log("Stats are up to date!!");      
          }

          setTimeout(function () {      
            loadStats();
          }, 3000);
        } 
      }


      var checkbox = document.querySelector("input[name=onoffswitch]");
      checkbox.addEventListener( 'change', async function () {
          if(this.checked) {
              let elements = document.getElementsByClassName("included_html");
              if (elements) {
                for (let i = 0; i < elements.length; i++) {
                  //elements[i].style.display = "block";
                  elements[i].style.display = "table-cell";
                }        
              }
              
              
              console.log("showing stats");
              showStats = true;
              await loadStats();
          } else {  
              let elements = document.getElementsByClassName("included_html");
              if (elements) {
                for (let i = 0; i < elements.length; i++) {
                  elements[i].style.display = "none";
                }        
              }
              //document.getElementById("included_html").style.display = "none";
              console.log("NOT showing stats");
              showStats = false;
          }
      });




    </script>

<!--
    <script src="worker.js"></script>
-->

    <link rel="stylesheet" type="text/css" href="./css/toggle.css">


  </div>

</body>

</html>
